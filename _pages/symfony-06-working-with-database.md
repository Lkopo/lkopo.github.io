---
layout: page
title: Working with database
permalink: /tutorial/symfony/06-working-with-database
---

[_Symfony Doctrine docs_](https://symfony.com/doc/current/doctrine.html)

In this exercise, we decide to store all our lucky numbers in database and display it on the page.
Symfony framework has support for [Doctrine](https://symfony.com/doc/current/doctrine.html) by default,
a powerful ORM framework which we will be using here.

### Creating an entity

A PHP object we would like to save to the database and obtain it when necessary via ORM is called an Entity.
Entities can have relations on other entities and each object has its unique identifier to be distinguishable
among other objects for specific Entity.

In symfony we can create a skeleton Entity simple by using another built command:

```bash
symfony console make:entity
```

An Entity creation wizard will run and you will be prompted to enter entity name, its fields, their types
and whether they can be nullable or not. Let's say we would like to create an Entity `RandomNumber` which
will represent our random numbers we generated:

```
 Class name of the entity to create or update (e.g. BravePizza):
 > RandomNumber

 created: src/Entity/RandomNumber.php
 created: src/Repository/RandomNumberRepository.php

 Entity generated! Now let's add some fields!
 You can always add more fields later manually or by re-running this command.

 New property name (press <return> to stop adding fields):
 > max

 Field type (enter ? to see all types) [string]:
 > integer

 Can this field be null in the database (nullable) (yes/no) [no]:
 > 

 updated: src/Entity/RandomNumber.php

 Add another property? Enter the property name (or press <return> to stop adding fields):
 > value

 Field type (enter ? to see all types) [string]:
 > integer

 Can this field be null in the database (nullable) (yes/no) [no]:
 >

 updated: src/Entity/RandomNumber.php

 Add another property? Enter the property name (or press <return> to stop adding fields):
 >


  Success!


 Next: When you're ready, create a migration with php bin/console make:migration
```

As we can see, we created an Entity `RandomNumber` with integer non-null fields `max`
and `value`. Property `max` represents what is the possible maximum we set and `value`
is the random generated value we get.

Have a look at newly generated entity. Do you see some field we didn't specify? Of course. Each
entity gets an automatically generated `id` field which is an unique identifier. It's non-nullable,
autogenerated value when we insert new Entities and we use this value in order to update or
delete an existing entity instance. We can also see that we already have all getters and setters
already implemented so we don't need to do anything more with this entity for now.

What we really need is to update the database so the new table for `RandomNumber` Entity can be created.
As we did in our [exercise 02](/tutorial/symfony/02-setting-db-to-mysql-and-migrating-database#migrating-database-tables),
we will create a migration file as well as execute it:

```bash
symfony console make:migration
...
symfony console doctrine:migrations:migrate
```

Go check your database whether the table was created or not. If everything was run successfully, you
should see a newly created table `random_number` with 3 columns: `id`, `max` and `value`. As for now,
the table is empty.

But it won't for long...

### Persisting objects to the database

For now on, we want to save each generated random number to the database,
so we can show our colleagues how lucky we are, or we are not.

To do so, we need to update our `RandomController` to save the Entity:

```php
<?php
// ...
class RandomController extends AbstractController
{
    // ...
    public function generate(int $max)
    {
        $number = random_int(0, $max);
    
        // obtain the entityManager instance, it's responsible to persist new objects and flush all the changes
        $entityManager = $this->getDoctrine()->getManager();
    
        // create a new object of RandomNumber Entity
        $randomNumber = new RandomNumber();
        $randomNumber
            ->setMax($max)
            ->setValue($number);
    
        // entityManager will get to know we want to save a RandomNumber object, but no SQL statements are executed yet
        $entityManager->persist($randomNumber);
    
        // executing that we will flush all the changes and Doctrine will execute all SQL statements to update database
        // (for now it's just INSERT)
        $entityManager->flush();
    
        return $this->render('random/generate.html.twig', [
            'number' => $number
        ]);
    }
}
```

Let's check it! Visit random number generator and right after check your database table. You should see the record there.
Congratulations, now you are able to store new records!

What we did here? First, we get an instance of Doctrine's Entity Manager (EM). This Entity Manager is responsible for
saving, updating and removing entities from/to the database.

Later, we created an instance of our new `RandomNumber` entity and assigned the maximum set number and already generated
random value. Then we told the EM we would like to save/persist a new object of `RandomNumber` to the database. To this
point, nothing is saved/changed yet. You can continue with your changes if you have more objects to change, save or delete.

At the end, we called the `flush()` method on EM, which will gather all the changes and save them to the database
atomically. This means the Doctrine is making a transaction and everything inside the transaction must be executed
successfully in order to have changes applied or nothing is saved and database is rolled back. This is a safe way to apply
multiple changes at once without the risk half of the data changes will be saved and second half will not.

Let's move on and try to display the list of our (not) lucky guesses.

### Fetching the records from the database

We will create a new controller's page to show the list of our numbers. First, we create a new template `list.html.twig`
which will contain a table of stored numbers. Let's assume we will obtain input variable `numbers` which is an array of
`RandomNumber` objects:

```twig
{% raw %}{% extends 'base.html.twig' %}

{% block title %}List of our lucky numbers{% endblock %}

{% block main %}
    <h1>List of our lucky numbers</h1>

    <table class="table">
        <tr>
            <th>ID</th>
            <th>Possible maximum</th>
            <th>Lucky number</th>
        </tr>
        {% for number in numbers %}
            <tr>
                <td>{{ number.id }}</td>
                <td>{{ number.max }}</td>
                <td>{{ number.value }}</td>
            </tr>
        {% endfor %}
    </table>
{% endblock %}

{% block sidebar %}
    {{ parent() }}

    {{ show_source_code(_self) }}
{% endblock %}{% endraw %}
```

We are using [for](https://twig.symfony.com/doc/3.x/tags/for.html) syntax in twig to iterate through records of an array.

Since we have our template ready, we can focus on controller to create a new method with route `/list` to render
the template with fetched list of numbers. Let's do what we already know:

```php
<?php
// ...
class RandomController extends AbstractController
{
    // ...
    /**
     * @Route("/list", name="random_list")
     */
    public function list()
    {
        $numbers = [];
        
        return $this->render('random/list.html.twig', [
            'numbers' => $numbers
        ]);
    }
}
```

This is enough to make our endpoint working and being able to see our new page. Visit
[http://localhost/en/random/list](http://localhost/en/random/list) to see our new table.

Looking nice, right? No? That's because it's empty. We should fill the table with our numbers. Firstly, we need to fetch
our data and for that we use repositories. Repositories are stored in `src/Repository` folder and as you can notice
we already have a `RandomNumberRepository` generated. This was created during generation of entity process. To obtain
the repository instance, we do it by `$this->getDoctrine()->getRepository(RandomNumber::class)` instead of creating
a new instance of `RandomNumberRepository`. There are a few inherited methods already available for each repository:

- `find()`
- `findAll()`
- `findBy()`
- `fndOneBy()`

We use `findAll()` to obtain all our stored numbers. Let's put everything together:

```php
<?php
// ...
class RandomController extends AbstractController
{
    // ...
    /**
     * @Route("/list", name="random_list")
     */
    public function list()
    {
        $numbers = $this->getDoctrine()
            ->getRepository(RandomNumber::class) // gets RandomNumberRepository instance
            ->findAll(); // fetch all objects for RandomNumber Entity

        return $this->render('random/list.html.twig', [
            'numbers' => $numbers
        ]);
    }
}
```

Now refresh the page again. You should see your lucky numbers now. Pretty easy right?

### Using Query Builder for custom queries

Doctrine comes with its
[custom Query Builder](https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/query-builder.html)
safe to build complex selection queries. Let's say we want to not to show all records from the database, but only these
where `value` is higher than specified value.

To do so, we create a new method `findByValueGreaterThan(int $value)`. Unlike Spring Hibernate, the name of the method
is not parsed and converted to the query. We need to create that query by ourselves:

```php
<?php
// ...
class RandomNumberRepository extends ServiceEntityRepository
{
    // ...
    public function findByValueGreaterThan(int $value): array
    {
        return $this->createQueryBuilder('rn') // rn is an alias for Random Number entity for the rest of the query
            ->where('rn.value > :value')
            ->orderBy('rn.value', 'DESC')
            ->setParameter('value', $value)
            ->getQuery()
            ->getResult();
    }
    // ...
}
```

This method simple builds a `SELECT` query for `RandomNumber` entity as `rn` with condition that it's `value` will be
higher than `$value`. The last methods `getQuery()` constructs the query and `getResult()` executes the query and
returns the result as an array of `RandomNumber` objects.

Now we need to update `list()` method in our `RandomNumberController` to use our new repository method
instead of `findAll()`:

```php
<?php
// ...
class RandomNumberController extends AbstractController
{
    // ...
    public function list()
    {
        $numbers = $this->getDoctrine()
            ->getRepository(RandomNumber::class) // gets RandomNumberRepository instance
            ->findByValueGreaterThan(100);

        return $this->render('random/list.html.twig', [
            'numbers' => $numbers
        ]);
    }
    // ...
}
```

That's it. Now refresh the list again and you should see only these Random Numbers which value is higher than `100`. But
this only hides the unlucky numbers, they are still in database. What if someone look into the database and see we are
cheating? Let's get rid of them!

### Deleting the object from the database

As we would like to show how only lucky we are and remove the not lucky numbers, we will add the delete option
for each number. For that, we will create a new endpoint to delete an RandomNumber object:

```php
<?php
// ...
class RandomController extends AbstractController
{
    // ...
    /**
     * @Route("/delete/{id}", name="random_delete", requirements={"id": "\d+"})
     */
    public function delete(int $id)
    {
        // obtain the number from the database
        $number = $this->getDoctrine()
            ->getRepository(RandomNumber::class)
            ->find($id);

        // throw an 404 exception in case the number doesn't exist under specified id
        if (!$number) {
            throw $this->createNotFoundException('The random number under id ' . $id . ' is not in our database!');
        }

        // obtain Entity Manager instance
        $entityManager = $this->getDoctrine()->getManager();

        // tell the EM we want to remove our object
        $entityManager->remove($number);

        // execute all the changes including delete action in transaction
        $entityManager->flush();

        // throw flash message
        $this->addFlash('success', 'Your lucky number was successfully deleted.');

        // redirect back to the list of lucky numbers
        return $this->redirectToRoute('random_list');
    }
}
```

So what was done here - first, we tried to obtain requested `RandomNumber` object by its identifier - `id`.
For that we used `find(int $id)` method, already supported by Doctrine by default. If the object is falsy (`null`),
we throw an `NotFoundException` that requested number was not found in our database.

If the record was found, we obtain Entity Manager to delete our object. To do so, we call `remove()` method on Entity
Manager where we tell we want to remove that instance. By calling flush, we execute all the requested changes within
transaction.

At the end, we show a toast (flash) message on the page that record was deleted successfully and redirect the user
to the list of the lucky numbers. As you can notice, instead of creating a new view, we just redirect the user back
to the list.

Let's add a new column _Action_ to our table in `list.html.twig` file with a link to edit each entry:

```twig
{% raw %}{% block main %}
    <h1>List of our lucky numbers</h1>

    <table class="table">
        <tr>
            <th>ID</th>
            <th>Possible maximum</th>
            <th>Lucky number</th>
            <th>Action</th> <!-- New line here  -->
        </tr>
        {% for number in numbers %}
            <tr>
                <td>{{ number.id }}</td>
                <td>{{ number.max }}</td>
                <td>{{ number.value }}</td>
                <td><a href="{{ path('random_delete', {'id': number.id }) }}">Delete</a></td> <!-- New line here  -->
            </tr>
        {% endfor %}
    </table>
{% endblock %}{% endraw %}
```
Refresh the list [http://localhost/en/random/list](http://localhost/en/random/list) to see our new column and
click on _Delete_ on one of your lucky numbers. If no records are there, just
[generate](http://localhost/en/random/generate) a new one.

### Updating the object in the database

Updating the object works almost the same way like creating or deleting one. The first part is same as for deleting - 
try to obtain the existing object from the database. If successful, perform your changes on that instance instead of
creating a new one. If the object was updated, we just call a `flush()` method which will obtain and execute all
the changes including these ones we fetched from the Entity Manager:

```php
<?php
// ...
class RandomController extends AbstractController
{
    /**
     * @Route("/edit/{id}", name="random_edit", requirements={"id": "\d+"})
     */
    public function edit(int $id)
    {
        // obtain the number from the database
        $number = $this->getDoctrine()
            ->getRepository(RandomNumber::class)
            ->find($id);

        // throw an 404 exception in case the number doesn't exist under specified id
        if (!$number) {
            throw $this->createNotFoundException('The random number under id ' . $id . ' is not in our database!');
        }

        // obtain Entity Manager instace
        $entityManager = $this->getDoctrine()->getManager();

        // set the new value which is again a new random value
        $number->setValue(random_int(0, $number->getMax()));

        // execute all the changes in transaction
        $entityManager->flush();

        // throw flash message
        $this->addFlash('success', 'Your lucky number was successfully updated.');

        // redirect back to the list of lucky numbers
        return $this->redirectToRoute('random_list');
    }
}
```

Let's add a new action _Regenerate_ to our table:

```twig
{% raw %}<td><a href="{{ path('random_delete', {'id': number.id }) }}">Delete</a> |
    <a href="{{ path('random_edit', {'id': number.id}) }}">Regenerate</a></td> <!-- New line here -->{% endraw %}
```

Now refresh the list again and click the _Regenerate_ link. You should see a new value of that number. Hope this time
you get more lucky values.

And that's it for database exercise. In the next [exercise 07](/tutorial/symfony/07-working-with-forms), we will work with forms so
we can set the value instead of regenerating until we are satisfied with new value.
